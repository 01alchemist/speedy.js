// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Compiler Integration array-element-access. 1`] = `
"; ModuleID = 'test/cases/array-element-access.case.ts'
source_filename = \\"test/cases/array-element-access.case.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

define i32 @arrayElementAccessCase() {
entry:
  %0 = alloca [5 x i32]
  %array = alloca i4*
  %returnValue = alloca i32
  %1 = getelementptr inbounds [5 x i32], [5 x i32]* %0, i32 0, i32 0
  store i32 1, i32* %1, align 4
  %2 = getelementptr inbounds [5 x i32], [5 x i32]* %0, i32 0, i32 1
  store i32 2, i32* %2, align 4
  %3 = getelementptr inbounds [5 x i32], [5 x i32]* %0, i32 0, i32 2
  store i32 3, i32* %3, align 4
  %4 = getelementptr inbounds [5 x i32], [5 x i32]* %0, i32 0, i32 3
  store i32 4, i32* %4, align 4
  %5 = getelementptr inbounds [5 x i32], [5 x i32]* %0, i32 0, i32 4
  store i32 5, i32* %5, align 4
  %array1 = getelementptr inbounds [5 x i32], [5 x i32]* %0, i32 0, i32 0
  %6 = call i4* @new_array_i32(i32 5, i32* %array1)
  store i4* %6, i4** %array, align 4
  %array2 = load i4*, i4** %array, align 4
  %array.get = call i32 @array_get_i32(i4* %array2, i32 2)
  store i32 %array.get, i32* %returnValue
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %7 = load i4*, i4** %array
  call void @delete_array_i32(i4* %7)
  %return = load i32, i32* %returnValue
  ret i32 %return
}

declare i4* @new_array_i32(i32, i32*)

declare i32 @array_get_i32(i4*, i32)

declare void @delete_array_i32(i4*)
"
`;

exports[`Compiler Integration array-literal-expression. 1`] = `
"; ModuleID = 'test/cases/array-literal-expression.case.ts'
source_filename = \\"test/cases/array-literal-expression.case.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

define i4* @constantArrayLiteral() {
entry:
  %0 = alloca [4 x i32]
  %returnValue = alloca i4*
  %1 = getelementptr inbounds [4 x i32], [4 x i32]* %0, i32 0, i32 0
  store i32 1, i32* %1, align 4
  %2 = getelementptr inbounds [4 x i32], [4 x i32]* %0, i32 0, i32 1
  store i32 2, i32* %2, align 4
  %3 = getelementptr inbounds [4 x i32], [4 x i32]* %0, i32 0, i32 2
  store i32 3, i32* %3, align 4
  %4 = getelementptr inbounds [4 x i32], [4 x i32]* %0, i32 0, i32 3
  store i32 4, i32* %4, align 4
  %array = getelementptr inbounds [4 x i32], [4 x i32]* %0, i32 0, i32 0
  %5 = call i4* @new_array_i32(i32 4, i32* %array)
  store i4* %5, i4** %returnValue
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return = load i4*, i4** %returnValue
  ret i4* %return
}

declare i4* @new_array_i32(i32, i32*)
"
`;

exports[`Compiler Integration branched-function-returning-void. 1`] = `
"; ModuleID = 'test/cases/branched-function-returning-void.case.ts'
source_filename = \\"test/cases/branched-function-returning-void.case.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

define void @branchedFunctionReturningVoid(i32 %arg1) {
entry:
  %count = alloca i32
  %arg = alloca i32
  store i32 %arg1, i32* %arg
  %arg2 = load i32, i32* %arg, align 4
  %0 = icmp sgt i32 %arg2, 10
  br i1 %0, label %then, label %else

then:                                             ; preds = %entry
  %count3 = load i32, i32* %count, align 4
  store i32 0, i32* %count
  br label %if-successor

else:                                             ; preds = %entry
  %count4 = load i32, i32* %count, align 4
  %arg5 = load i32, i32* %arg, align 4
  store i32 %arg5, i32* %count
  br label %if-successor

if-successor:                                     ; preds = %else, %then
  %count6 = load i32, i32* %count, align 4
  %1 = add i32 %count6, 1
  store i32 %1, i32* %count
  ret void
}
"
`;

exports[`Compiler Integration branched-function-with-return-value. 1`] = `
"; ModuleID = 'test/cases/branched-function-with-return-value.case.ts'
source_filename = \\"test/cases/branched-function-with-return-value.case.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

define i1 @isPrime(i32 %x1) {
entry:
  %x = alloca i32
  store i32 %x1, i32* %x
  %returnValue = alloca i1
  %x2 = load i32, i32* %x, align 4
  %0 = icmp sle i32 %x2, 2
  br i1 %0, label %then, label %else

then:                                             ; preds = %entry
  store i1 true, i1* %returnValue
  br label %if-successor

else:                                             ; preds = %entry
  store i1 false, i1* %returnValue
  br label %if-successor

if-successor:                                     ; preds = %then, %else
  %return = load i1, i1* %returnValue
  ret i1 %return
}
"
`;

exports[`Compiler Integration for-with-return-statement. 1`] = `
"; ModuleID = 'test/cases/for-with-return-statement.case.ts'
source_filename = \\"test/cases/for-with-return-statement.case.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

define i1 @isPrime(i32 %x1) {
entry:
  %i = alloca i32
  %x = alloca i32
  store i32 %x1, i32* %x
  %returnValue = alloca i1
  %x2 = load i32, i32* %x, align 4
  %0 = icmp sle i32 %x2, 2
  br i1 %0, label %then, label %if-successor

then:                                             ; preds = %entry
  store i1 false, i1* %returnValue
  br label %returnBlock

if-successor:                                     ; preds = %entry
  store i32 2, i32* %i, align 4
  br label %for-header

for-header:                                       ; preds = %if-successor8, %if-successor
  %i3 = load i32, i32* %i, align 4
  %x4 = load i32, i32* %x, align 4
  %1 = sitofp i32 %x4 to float
  %2 = call float @llvm.sqrt.f32(float %1)
  %3 = fptosi float %2 to i32
  %4 = icmp slt i32 %i3, %3
  br i1 %4, label %for-body, label %for-successor

for-body:                                         ; preds = %for-header
  %x5 = load i32, i32* %x, align 4
  %i6 = load i32, i32* %i, align 4
  %5 = srem i32 %x5, %i6
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %then7, label %if-successor8

then7:                                            ; preds = %for-body
  store i1 false, i1* %returnValue
  br label %returnBlock

if-successor8:                                    ; preds = %for-body
  %i9 = load i32, i32* %i, align 4
  %7 = add i32 %i9, 1
  store i32 %7, i32* %i
  br label %for-header

for-successor:                                    ; preds = %for-header
  store i1 true, i1* %returnValue
  br label %returnBlock

returnBlock:                                      ; preds = %for-successor, %then7, %then
  %return = load i1, i1* %returnValue
  ret i1 %return
}

; Function Attrs: nounwind readnone
declare float @llvm.sqrt.f32(float) #0

; Function Attrs: nounwind readnone
declare double @llvm.sqrt.f64(double) #0

attributes #0 = { nounwind readnone }
"
`;

exports[`Compiler Integration if-else-if-else. 1`] = `
"; ModuleID = 'test/cases/if-else-if-else.case.ts'
source_filename = \\"test/cases/if-else-if-else.case.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

define i32 @cmp(i32 %x1, i32 %y2) {
entry:
  %result = alloca i32
  %x = alloca i32
  store i32 %x1, i32* %x
  %y = alloca i32
  store i32 %y2, i32* %y
  %returnValue = alloca i32
  %x3 = load i32, i32* %x, align 4
  %y4 = load i32, i32* %y, align 4
  %0 = icmp slt i32 %x3, %y4
  br i1 %0, label %then, label %else

then:                                             ; preds = %entry
  %result5 = load i32, i32* %result, align 4
  store i32 -1, i32* %result
  br label %if-successor

else:                                             ; preds = %entry
  %x6 = load i32, i32* %x, align 4
  %y7 = load i32, i32* %y, align 4
  %1 = icmp eq i32 %x6, %y7
  br i1 %1, label %then8, label %else10

then8:                                            ; preds = %else
  %result9 = load i32, i32* %result, align 4
  store i32 0, i32* %result
  br label %if-successor

else10:                                           ; preds = %else
  %result11 = load i32, i32* %result, align 4
  store i32 1, i32* %result
  br label %if-successor

if-successor:                                     ; preds = %then8, %else10, %then
  %result12 = load i32, i32* %result, align 4
  store i32 %result12, i32* %returnValue
  br label %returnBlock

returnBlock:                                      ; preds = %if-successor
  %return = load i32, i32* %returnValue
  ret i32 %return
}
"
`;

exports[`Compiler Integration if-statement. 1`] = `
"; ModuleID = 'test/cases/if-statement.case.ts'
source_filename = \\"test/cases/if-statement.case.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

define double @max(double %x1, double %y2) {
entry:
  %x = alloca double
  store double %x1, double* %x
  %y = alloca double
  store double %y2, double* %y
  %returnValue = alloca double
  %x3 = load double, double* %x, align 8
  %y4 = load double, double* %y, align 8
  %0 = fcmp ult double %x3, %y4
  br i1 %0, label %then, label %if-successor

then:                                             ; preds = %entry
  %y5 = load double, double* %y, align 8
  store double %y5, double* %returnValue
  br label %returnBlock

if-successor:                                     ; preds = %entry
  %x6 = load double, double* %x, align 8
  store double %x6, double* %returnValue
  br label %returnBlock

returnBlock:                                      ; preds = %if-successor, %then
  %return = load double, double* %returnValue
  ret double %return
}
"
`;

exports[`Compiler Integration initialized-variable-declaration. 1`] = `
"; ModuleID = 'test/cases/initialized-variable-declaration.case.ts'
source_filename = \\"test/cases/initialized-variable-declaration.case.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

define void @initializedVariableDeclaration() {
entry:
  %x = alloca i32
  store i32 10, i32* %x, align 4
  ret void
}
"
`;

exports[`Compiler Integration uninitialized-variable-declaration. 1`] = `
"; ModuleID = 'test/cases/uninitialized-variable-declaration.case.ts'
source_filename = \\"test/cases/uninitialized-variable-declaration.case.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

define void @uninitializedVariableDeclaration() {
entry:
  %x = alloca double
  ret void
}
"
`;

exports[`Compiler Integration void-function-with-return-statement. 1`] = `
"; ModuleID = 'test/cases/void-function-with-return-statement.case.ts'
source_filename = \\"test/cases/void-function-with-return-statement.case.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

define void @voidFunctionWithReturnStatement(i32 %arg1) {
entry:
  %count = alloca i32
  %arg = alloca i32
  store i32 %arg1, i32* %arg
  %arg2 = load i32, i32* %arg, align 4
  %0 = icmp slt i32 %arg2, 10
  br i1 %0, label %then, label %if-successor

then:                                             ; preds = %entry
  br label %returnBlock

if-successor:                                     ; preds = %entry
  %arg3 = load i32, i32* %arg, align 4
  store i32 %arg3, i32* %count, align 4
  br label %returnBlock

returnBlock:                                      ; preds = %if-successor, %then
  ret void
}
"
`;
