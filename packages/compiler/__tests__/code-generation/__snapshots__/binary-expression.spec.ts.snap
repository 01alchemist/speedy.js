// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`BinaryExpression % 1`] = `
"; ModuleID = 'binary-expression/%.ts'
source_filename = \\"binary-expression/%.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @percent() {
entry:
  %sixDouble = alloca double
  %six = alloca i32
  store i32 6, i32* %six, align 4
  store double 6.000000e+00, double* %sixDouble, align 8
  %six1 = load i32, i32* %six, align 4
  %0 = srem i32 8, %six1
  %sixDouble2 = load double, double* %sixDouble, align 8
  %1 = frem double 8.000000e+00, %sixDouble2
  ret void
}
"
`;

exports[`BinaryExpression * 1`] = `
"; ModuleID = 'binary-expression/*.ts'
source_filename = \\"binary-expression/*.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @asterisk() {
entry:
  %doubleProduct = alloca double
  %intProduct = alloca i32
  store i32 12, i32* %intProduct, align 4
  %intProduct1 = load i32, i32* %intProduct, align 4
  %0 = mul i32 %intProduct1, 2
  store i32 %0, i32* %intProduct, align 4
  store double 1.200000e+01, double* %doubleProduct, align 8
  %doubleProduct2 = load double, double* %doubleProduct, align 8
  %1 = fmul double %doubleProduct2, 1.500000e+00
  store double %1, double* %doubleProduct, align 8
  ret void
}
"
`;

exports[`BinaryExpression ** 1`] = `
"; ModuleID = 'binary-expression/**.ts'
source_filename = \\"binary-expression/**.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @asteriskAsterisk() {
entry:
  %doubleProduct = alloca double
  %intProduct = alloca i32
  %0 = call float @llvm.powi.f32(float 3.000000e+00, i32 4)
  %1 = fptosi float %0 to i32
  store i32 %1, i32* %intProduct, align 4
  %intProduct1 = load i32, i32* %intProduct, align 4
  %2 = sitofp i32 %intProduct1 to float
  %3 = call float @llvm.powi.f32(float %2, i32 2)
  %4 = fptosi float %3 to i32
  store i32 %4, i32* %intProduct, align 4
  %5 = call double @llvm.pow.f64(double 3.000000e+00, double 4.000000e+00)
  store double %5, double* %doubleProduct, align 8
  %doubleProduct2 = load double, double* %doubleProduct, align 8
  %6 = call double @llvm.pow.f64(double %doubleProduct2, double 1.500000e+00)
  store double %6, double* %doubleProduct, align 8
  ret void
}

; Function Attrs: nounwind readnone
declare float @llvm.powi.f32(float, i32) #0

; Function Attrs: nounwind readnone
declare double @llvm.pow.f64(double, double) #0

attributes #0 = { nounwind readnone }
"
`;

exports[`BinaryExpression + 1`] = `
"; ModuleID = 'binary-expression/+.ts'
source_filename = \\"binary-expression/+.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @plus() {
entry:
  %twoDouble = alloca double
  %two = alloca i32
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  %two1 = load i32, i32* %two, align 4
  %0 = add i32 4, %two1
  %twoDouble2 = load double, double* %twoDouble, align 8
  %1 = fadd double 4.000000e+00, %twoDouble2
  %two3 = load i32, i32* %two, align 4
  %2 = add i32 %two3, 2
  store i32 %2, i32* %two, align 4
  %twoDouble4 = load double, double* %twoDouble, align 8
  %3 = fadd double %twoDouble4, 2.000000e+00
  store double %3, double* %twoDouble, align 8
  ret void
}
"
`;

exports[`BinaryExpression < 1`] = `
"; ModuleID = 'binary-expression/<.ts'
source_filename = \\"binary-expression/<.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @lessThan() {
entry:
  %trueValue = alloca i1
  %twoDouble = alloca double
  %two = alloca i32
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %0 = icmp slt i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %1 = fcmp ult double %twoDouble2, 4.000000e+00
  %trueValue3 = load i1, i1* %trueValue, align 1
  %2 = zext i1 %trueValue3 to i32
  %3 = icmp slt i32 %2, 0
  ret void
}
"
`;

exports[`BinaryExpression <= 1`] = `
"; ModuleID = 'binary-expression/<=.ts'
source_filename = \\"binary-expression/<=.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @lessThanEquals() {
entry:
  %trueValue = alloca i1
  %twoDouble = alloca double
  %two = alloca i32
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %0 = icmp slt i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %1 = fcmp ult double %twoDouble2, 4.000000e+00
  %trueValue3 = load i1, i1* %trueValue, align 1
  %2 = zext i1 %trueValue3 to i32
  %3 = icmp slt i32 %2, 0
  ret void
}
"
`;

exports[`BinaryExpression === 1`] = `
"; ModuleID = 'binary-expression/===.ts'
source_filename = \\"binary-expression/===.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @equalsEqualsEqualsToken() {
entry:
  %trueValue = alloca i1
  %threePointFour = alloca double
  %four = alloca i32
  store i32 4, i32* %four, align 4
  store double 3.400000e+00, double* %threePointFour, align 8
  store i1 true, i1* %trueValue, align 1
  %four1 = load i32, i32* %four, align 4
  %0 = icmp eq i32 %four1, 4
  %threePointFour2 = load double, double* %threePointFour, align 8
  %1 = fcmp oeq double %threePointFour2, 3.400000e+00
  %trueValue3 = load i1, i1* %trueValue, align 1
  %2 = icmp eq i1 %trueValue3, true
  ret void
}
"
`;

exports[`BinaryExpression > 1`] = `
"; ModuleID = 'binary-expression/>.ts'
source_filename = \\"binary-expression/>.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @greaterThan() {
entry:
  %trueValue = alloca i1
  %twoDouble = alloca double
  %two = alloca i32
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %0 = icmp sgt i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %1 = fcmp ogt double %twoDouble2, 4.000000e+00
  %trueValue3 = load i1, i1* %trueValue, align 1
  %2 = zext i1 %trueValue3 to i32
  %3 = icmp sgt i32 %2, 0
  ret void
}
"
`;

exports[`BinaryExpression >= 1`] = `
"; ModuleID = 'binary-expression/>=.ts'
source_filename = \\"binary-expression/>=.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @greaterThanEquals() {
entry:
  %trueValue = alloca i1
  %twoDouble = alloca double
  %two = alloca i32
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %0 = icmp sge i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %1 = fcmp oge double %twoDouble2, 4.000000e+00
  %trueValue3 = load i1, i1* %trueValue, align 1
  %2 = zext i1 %trueValue3 to i32
  %3 = icmp sge i32 %2, 0
  ret void
}
"
`;

exports[`BinaryExpression | 1`] = `
"; ModuleID = 'binary-expression/|.ts'
source_filename = \\"binary-expression/|.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @bar() {
entry:
  %intToInt = alloca i32
  %intValue = alloca i32
  %six = alloca i32
  store i32 6, i32* %six, align 4
  %six1 = load i32, i32* %six, align 4
  %0 = or i32 %six1, 8
  store i32 %0, i32* %six, align 4
  %AsInt32 = call i32 @toInt32d(double 3.560000e+00)
  store i32 %AsInt32, i32* %intValue, align 4
  store i32 3, i32* %intToInt, align 4
  ret void
}

declare i32 @toInt32d(double)
"
`;

exports[`BinaryExpression - 1`] = `
"; ModuleID = 'binary-expression/-.ts'
source_filename = \\"binary-expression/-.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @minus() {
entry:
  %twoDouble = alloca double
  %two = alloca i32
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  %two1 = load i32, i32* %two, align 4
  %0 = sub i32 4, %two1
  %twoDouble2 = load double, double* %twoDouble, align 8
  %1 = fsub double 4.000000e+00, %twoDouble2
  %two3 = load i32, i32* %two, align 4
  %2 = sub i32 %two3, 2
  store i32 %2, i32* %two, align 4
  %twoDouble4 = load double, double* %twoDouble, align 8
  %3 = fsub double %twoDouble4, 2.000000e+00
  store double %3, double* %twoDouble, align 8
  ret void
}
"
`;

exports[`BinaryExpression slash 1`] = `
"; ModuleID = 'binary-expression/slash.ts'
source_filename = \\"binary-expression/slash.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @slash() {
entry:
  %doubleProduct = alloca double
  %intProduct = alloca i32
  store i32 1, i32* %intProduct, align 4
  %intProduct1 = load i32, i32* %intProduct, align 4
  %0 = sdiv i32 %intProduct1, 2
  store i32 %0, i32* %intProduct, align 4
  store double 0x3FF5555555555555, double* %doubleProduct, align 8
  %doubleProduct2 = load double, double* %doubleProduct, align 8
  %1 = fdiv double %doubleProduct2, 1.500000e+00
  store double %1, double* %doubleProduct, align 8
  ret void
}
"
`;
