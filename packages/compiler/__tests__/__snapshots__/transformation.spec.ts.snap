// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Transformation does not rewrite source files without any speedyjs functions 1`] = `
"function isPrime(value) {
    if (value <= 2) {
        return false;
    }
    for (let i = 2; i < (Math.sqrt(value) | 0); ++i) {
        if (value % i === 0) {
            return false;
        }
    }
    return true;
}
"
`;

exports[`Transformation passes the configured global base to the module loader 1`] = `
"var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * Part of this source code has been taken from https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
var Allocation;
(function (Allocation) {
    /**
     * Tries to use _malloc()
     */
    Allocation[Allocation[\\"NORMAL\\"] = 0] = \\"NORMAL\\";
    /**
     * Lives for the duration of the current function call
     */
    Allocation[Allocation[\\"STACK\\"] = 1] = \\"STACK\\";
    /**
     * Cannot be freed
     */
    Allocation[Allocation[\\"STATIC\\"] = 2] = \\"STATIC\\";
    /**
     * Cannot be freed except through sbrk
     */
    Allocation[Allocation[\\"DYNAMIC\\"] = 3] = \\"DYNAMIC\\";
    /**
     * Do not allocate
     */
    Allocation[Allocation[\\"NONE\\"] = 4] = \\"NONE\\";
})(Allocation || (Allocation = {}));
function __moduleLoader(bytes, TOTAL_STACK, TOTAL_MEMORY, GLOBAL_BASE, STATIC_BUMP) {
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: TOTAL_MEMORY / WASM_PAGE_SIZE, maximum: TOTAL_MEMORY / WASM_PAGE_SIZE });
    var HEAP32 = new Int32Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    HEAP32[GLOBAL_BASE >> 2] = STACK_TOP;
    // where does the dynamic heap memory start
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    HEAP32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        // console.log(\\"sbrk\\");
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        var totalMemory = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = HEAP32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            console.error(\\"Cannot grow memory\\");
            return -1;
        }
        HEAP32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        totalMemory = TOTAL_MEMORY | 0;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            console.error('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which adjusts the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        return WebAssembly.instantiate(bytes.buffer, {
            env: {
                memory: memory,
                imports: {
                    \\"fmod\\": function frem(x, y) {
                        return x % y;
                    }
                },
                STACKTOP: STACK_TOP,
                \\"__cxa_allocate_exception\\": function () {
                    console.log(\\"__cxa_allocate_exception\\", arguments);
                },
                \\"__cxa_throw\\": function () {
                    console.log(\\"__cxa_throw\\", arguments);
                },
                \\"__cxa_find_matching_catch_2\\": function () {
                    console.log(\\"__cxa_find_matching_catch_2\\", arguments);
                },
                \\"__cxa_free_exception\\": function () {
                    console.log(\\"__cxa_free_exception\\", arguments);
                },
                \\"__resumeException\\": function () {
                    console.log(\\"__resumeException\\", arguments);
                },
                \\"abort\\": function (what) {
                    console.error(\\"Abort WASM for reason: \\" + what);
                },
                \\"invoke_ii\\": function (index, a1) {
                    return instance.exports.dynCall_ii(index, a1);
                },
                \\"invoke_iii\\": function (index, a1, a2) {
                    return instance.exports.dynCall_iii(index, a1, a2);
                },
                \\"invoke_viii\\": function (index, a1, a2, a3) {
                    return instance.exports.dynCall_viii(index, a1, a2, a3);
                },
                \\"sbrk\\": sbrk
            }
        }).then(function (result) { return instance = result.instance; });
    }
    var loaded = undefined;
    return function () {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance();
        return loaded;
    };
}
//# sourceMappingURL=get-wasm-module-function.js.map
const loadWasmModule_1 = __moduleLoader(Uint8Array.from([0, 97, 115, 109, 1, 0, 0, 0, 1, 134, 128, 128, 128, 0, 1, 96, 1, 127, 1, 127, 2, 144, 128, 128, 128, 0, 1, 3, 101, 110, 118, 6, 109, 101, 109, 111, 114, 121, 2, 0, 128, 2, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 7, 139, 128, 128, 128, 0, 1, 7, 105, 115, 80, 114, 105, 109, 101, 0, 0, 9, 129, 128, 128, 128, 0, 0, 10, 206, 128, 128, 128, 0, 1, 200, 128, 128, 128, 0, 1, 2, 127, 2, 127, 2, 64, 2, 64, 32, 0, 65, 3, 72, 13, 0, 65, 1, 33, 2, 32, 0, 183, 159, 170, 34, 1, 65, 3, 72, 13, 1, 65, 2, 33, 2, 3, 64, 32, 0, 32, 2, 111, 69, 13, 1, 32, 2, 65, 1, 106, 34, 2, 32, 1, 72, 13, 0, 11, 65, 1, 15, 11, 65, 0, 33, 2, 11, 32, 2, 11, 11]), 532480, 16777216, 4000, 8);
function isPrime(value) {
    return __awaiter(this, void 0, void 0, function* () { const instance = yield loadWasmModule_1(); return instance.exports.isPrime(value); });
}
"
`;

exports[`Transformation passes the configured total memory to the module loader 1`] = `
"var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * Part of this source code has been taken from https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
var Allocation;
(function (Allocation) {
    /**
     * Tries to use _malloc()
     */
    Allocation[Allocation[\\"NORMAL\\"] = 0] = \\"NORMAL\\";
    /**
     * Lives for the duration of the current function call
     */
    Allocation[Allocation[\\"STACK\\"] = 1] = \\"STACK\\";
    /**
     * Cannot be freed
     */
    Allocation[Allocation[\\"STATIC\\"] = 2] = \\"STATIC\\";
    /**
     * Cannot be freed except through sbrk
     */
    Allocation[Allocation[\\"DYNAMIC\\"] = 3] = \\"DYNAMIC\\";
    /**
     * Do not allocate
     */
    Allocation[Allocation[\\"NONE\\"] = 4] = \\"NONE\\";
})(Allocation || (Allocation = {}));
function __moduleLoader(bytes, TOTAL_STACK, TOTAL_MEMORY, GLOBAL_BASE, STATIC_BUMP) {
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: TOTAL_MEMORY / WASM_PAGE_SIZE, maximum: TOTAL_MEMORY / WASM_PAGE_SIZE });
    var HEAP32 = new Int32Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    HEAP32[GLOBAL_BASE >> 2] = STACK_TOP;
    // where does the dynamic heap memory start
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    HEAP32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        // console.log(\\"sbrk\\");
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        var totalMemory = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = HEAP32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            console.error(\\"Cannot grow memory\\");
            return -1;
        }
        HEAP32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        totalMemory = TOTAL_MEMORY | 0;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            console.error('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which adjusts the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        return WebAssembly.instantiate(bytes.buffer, {
            env: {
                memory: memory,
                imports: {
                    \\"fmod\\": function frem(x, y) {
                        return x % y;
                    }
                },
                STACKTOP: STACK_TOP,
                \\"__cxa_allocate_exception\\": function () {
                    console.log(\\"__cxa_allocate_exception\\", arguments);
                },
                \\"__cxa_throw\\": function () {
                    console.log(\\"__cxa_throw\\", arguments);
                },
                \\"__cxa_find_matching_catch_2\\": function () {
                    console.log(\\"__cxa_find_matching_catch_2\\", arguments);
                },
                \\"__cxa_free_exception\\": function () {
                    console.log(\\"__cxa_free_exception\\", arguments);
                },
                \\"__resumeException\\": function () {
                    console.log(\\"__resumeException\\", arguments);
                },
                \\"abort\\": function (what) {
                    console.error(\\"Abort WASM for reason: \\" + what);
                },
                \\"invoke_ii\\": function (index, a1) {
                    return instance.exports.dynCall_ii(index, a1);
                },
                \\"invoke_iii\\": function (index, a1, a2) {
                    return instance.exports.dynCall_iii(index, a1, a2);
                },
                \\"invoke_viii\\": function (index, a1, a2, a3) {
                    return instance.exports.dynCall_viii(index, a1, a2, a3);
                },
                \\"sbrk\\": sbrk
            }
        }).then(function (result) { return instance = result.instance; });
    }
    var loaded = undefined;
    return function () {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance();
        return loaded;
    };
}
//# sourceMappingURL=get-wasm-module-function.js.map
const loadWasmModule_1 = __moduleLoader(Uint8Array.from([0, 97, 115, 109, 1, 0, 0, 0, 1, 134, 128, 128, 128, 0, 1, 96, 1, 127, 1, 127, 2, 144, 128, 128, 128, 0, 1, 3, 101, 110, 118, 6, 109, 101, 109, 111, 114, 121, 2, 0, 160, 1, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 7, 139, 128, 128, 128, 0, 1, 7, 105, 115, 80, 114, 105, 109, 101, 0, 0, 9, 129, 128, 128, 128, 0, 0, 10, 206, 128, 128, 128, 0, 1, 200, 128, 128, 128, 0, 1, 2, 127, 2, 127, 2, 64, 2, 64, 32, 0, 65, 3, 72, 13, 0, 65, 1, 33, 2, 32, 0, 183, 159, 170, 34, 1, 65, 3, 72, 13, 1, 65, 2, 33, 2, 3, 64, 32, 0, 32, 2, 111, 69, 13, 1, 32, 2, 65, 1, 106, 34, 2, 32, 1, 72, 13, 0, 11, 65, 1, 15, 11, 65, 0, 33, 2, 11, 32, 2, 11, 11]), 532480, 10485760, 1024, 8);
function isPrime(value) {
    return __awaiter(this, void 0, void 0, function* () { const instance = yield loadWasmModule_1(); return instance.exports.isPrime(value); });
}
"
`;

exports[`Transformation passes the configured total stack to the module loader 1`] = `
"var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * Part of this source code has been taken from https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
var Allocation;
(function (Allocation) {
    /**
     * Tries to use _malloc()
     */
    Allocation[Allocation[\\"NORMAL\\"] = 0] = \\"NORMAL\\";
    /**
     * Lives for the duration of the current function call
     */
    Allocation[Allocation[\\"STACK\\"] = 1] = \\"STACK\\";
    /**
     * Cannot be freed
     */
    Allocation[Allocation[\\"STATIC\\"] = 2] = \\"STATIC\\";
    /**
     * Cannot be freed except through sbrk
     */
    Allocation[Allocation[\\"DYNAMIC\\"] = 3] = \\"DYNAMIC\\";
    /**
     * Do not allocate
     */
    Allocation[Allocation[\\"NONE\\"] = 4] = \\"NONE\\";
})(Allocation || (Allocation = {}));
function __moduleLoader(bytes, TOTAL_STACK, TOTAL_MEMORY, GLOBAL_BASE, STATIC_BUMP) {
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: TOTAL_MEMORY / WASM_PAGE_SIZE, maximum: TOTAL_MEMORY / WASM_PAGE_SIZE });
    var HEAP32 = new Int32Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    HEAP32[GLOBAL_BASE >> 2] = STACK_TOP;
    // where does the dynamic heap memory start
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    HEAP32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        // console.log(\\"sbrk\\");
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        var totalMemory = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = HEAP32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            console.error(\\"Cannot grow memory\\");
            return -1;
        }
        HEAP32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        totalMemory = TOTAL_MEMORY | 0;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            console.error('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which adjusts the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        return WebAssembly.instantiate(bytes.buffer, {
            env: {
                memory: memory,
                imports: {
                    \\"fmod\\": function frem(x, y) {
                        return x % y;
                    }
                },
                STACKTOP: STACK_TOP,
                \\"__cxa_allocate_exception\\": function () {
                    console.log(\\"__cxa_allocate_exception\\", arguments);
                },
                \\"__cxa_throw\\": function () {
                    console.log(\\"__cxa_throw\\", arguments);
                },
                \\"__cxa_find_matching_catch_2\\": function () {
                    console.log(\\"__cxa_find_matching_catch_2\\", arguments);
                },
                \\"__cxa_free_exception\\": function () {
                    console.log(\\"__cxa_free_exception\\", arguments);
                },
                \\"__resumeException\\": function () {
                    console.log(\\"__resumeException\\", arguments);
                },
                \\"abort\\": function (what) {
                    console.error(\\"Abort WASM for reason: \\" + what);
                },
                \\"invoke_ii\\": function (index, a1) {
                    return instance.exports.dynCall_ii(index, a1);
                },
                \\"invoke_iii\\": function (index, a1, a2) {
                    return instance.exports.dynCall_iii(index, a1, a2);
                },
                \\"invoke_viii\\": function (index, a1, a2, a3) {
                    return instance.exports.dynCall_viii(index, a1, a2, a3);
                },
                \\"sbrk\\": sbrk
            }
        }).then(function (result) { return instance = result.instance; });
    }
    var loaded = undefined;
    return function () {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance();
        return loaded;
    };
}
//# sourceMappingURL=get-wasm-module-function.js.map
const loadWasmModule_1 = __moduleLoader(Uint8Array.from([0, 97, 115, 109, 1, 0, 0, 0, 1, 134, 128, 128, 128, 0, 1, 96, 1, 127, 1, 127, 2, 144, 128, 128, 128, 0, 1, 3, 101, 110, 118, 6, 109, 101, 109, 111, 114, 121, 2, 0, 128, 2, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 7, 139, 128, 128, 128, 0, 1, 7, 105, 115, 80, 114, 105, 109, 101, 0, 0, 9, 129, 128, 128, 128, 0, 0, 10, 206, 128, 128, 128, 0, 1, 200, 128, 128, 128, 0, 1, 2, 127, 2, 127, 2, 64, 2, 64, 32, 0, 65, 3, 72, 13, 0, 65, 1, 33, 2, 32, 0, 183, 159, 170, 34, 1, 65, 3, 72, 13, 1, 65, 2, 33, 2, 3, 64, 32, 0, 32, 2, 111, 69, 13, 1, 32, 2, 65, 1, 106, 34, 2, 32, 1, 72, 13, 0, 11, 65, 1, 15, 11, 65, 0, 33, 2, 11, 32, 2, 11, 11]), 1048576, 16777216, 1024, 8);
function isPrime(value) {
    return __awaiter(this, void 0, void 0, function* () { const instance = yield loadWasmModule_1(); return instance.exports.isPrime(value); });
}
"
`;

exports[`Transformation rewrites the speedyjs function to call into the web assembly module 1`] = `
"var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * Part of this source code has been taken from https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
var Allocation;
(function (Allocation) {
    /**
     * Tries to use _malloc()
     */
    Allocation[Allocation[\\"NORMAL\\"] = 0] = \\"NORMAL\\";
    /**
     * Lives for the duration of the current function call
     */
    Allocation[Allocation[\\"STACK\\"] = 1] = \\"STACK\\";
    /**
     * Cannot be freed
     */
    Allocation[Allocation[\\"STATIC\\"] = 2] = \\"STATIC\\";
    /**
     * Cannot be freed except through sbrk
     */
    Allocation[Allocation[\\"DYNAMIC\\"] = 3] = \\"DYNAMIC\\";
    /**
     * Do not allocate
     */
    Allocation[Allocation[\\"NONE\\"] = 4] = \\"NONE\\";
})(Allocation || (Allocation = {}));
function __moduleLoader(bytes, TOTAL_STACK, TOTAL_MEMORY, GLOBAL_BASE, STATIC_BUMP) {
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: TOTAL_MEMORY / WASM_PAGE_SIZE, maximum: TOTAL_MEMORY / WASM_PAGE_SIZE });
    var HEAP32 = new Int32Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    HEAP32[GLOBAL_BASE >> 2] = STACK_TOP;
    // where does the dynamic heap memory start
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    HEAP32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        // console.log(\\"sbrk\\");
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        var totalMemory = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = HEAP32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            console.error(\\"Cannot grow memory\\");
            return -1;
        }
        HEAP32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        totalMemory = TOTAL_MEMORY | 0;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            console.error('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which adjusts the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        return WebAssembly.instantiate(bytes.buffer, {
            env: {
                memory: memory,
                imports: {
                    \\"fmod\\": function frem(x, y) {
                        return x % y;
                    }
                },
                STACKTOP: STACK_TOP,
                \\"__cxa_allocate_exception\\": function () {
                    console.log(\\"__cxa_allocate_exception\\", arguments);
                },
                \\"__cxa_throw\\": function () {
                    console.log(\\"__cxa_throw\\", arguments);
                },
                \\"__cxa_find_matching_catch_2\\": function () {
                    console.log(\\"__cxa_find_matching_catch_2\\", arguments);
                },
                \\"__cxa_free_exception\\": function () {
                    console.log(\\"__cxa_free_exception\\", arguments);
                },
                \\"__resumeException\\": function () {
                    console.log(\\"__resumeException\\", arguments);
                },
                \\"abort\\": function (what) {
                    console.error(\\"Abort WASM for reason: \\" + what);
                },
                \\"invoke_ii\\": function (index, a1) {
                    return instance.exports.dynCall_ii(index, a1);
                },
                \\"invoke_iii\\": function (index, a1, a2) {
                    return instance.exports.dynCall_iii(index, a1, a2);
                },
                \\"invoke_viii\\": function (index, a1, a2, a3) {
                    return instance.exports.dynCall_viii(index, a1, a2, a3);
                },
                \\"sbrk\\": sbrk
            }
        }).then(function (result) { return instance = result.instance; });
    }
    var loaded = undefined;
    return function () {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance();
        return loaded;
    };
}
//# sourceMappingURL=get-wasm-module-function.js.map
const loadWasmModule_1 = __moduleLoader(Uint8Array.from([0, 97, 115, 109, 1, 0, 0, 0, 1, 134, 128, 128, 128, 0, 1, 96, 1, 127, 1, 127, 2, 144, 128, 128, 128, 0, 1, 3, 101, 110, 118, 6, 109, 101, 109, 111, 114, 121, 2, 0, 128, 2, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 7, 139, 128, 128, 128, 0, 1, 7, 105, 115, 80, 114, 105, 109, 101, 0, 0, 9, 129, 128, 128, 128, 0, 0, 10, 206, 128, 128, 128, 0, 1, 200, 128, 128, 128, 0, 1, 2, 127, 2, 127, 2, 64, 2, 64, 32, 0, 65, 3, 72, 13, 0, 65, 1, 33, 2, 32, 0, 183, 159, 170, 34, 1, 65, 3, 72, 13, 1, 65, 2, 33, 2, 3, 64, 32, 0, 32, 2, 111, 69, 13, 1, 32, 2, 65, 1, 106, 34, 2, 32, 1, 72, 13, 0, 11, 65, 1, 15, 11, 65, 0, 33, 2, 11, 32, 2, 11, 11]), 532480, 16777216, 1024, 8);
function isPrime(value) {
    return __awaiter(this, void 0, void 0, function* () { const instance = yield loadWasmModule_1(); return instance.exports.isPrime(value); });
}
"
`;
