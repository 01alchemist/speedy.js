// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Array [1, 2, 3] 1`] = `
"; ModuleID = '__tests__/cases/array/[1, 2, 3].ts'
source_filename = \\"__tests__/cases/array/[1, 2, 3].ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define { i32, i32, i4* }* @arrayLiteral() {
entry:
  %items = alloca [4 x i32]
  %empty = alloca { i32, i32, i4* }*
  %return = alloca { i32, i32, i4* }*
  %0 = call { i32, i32, i4* }* @ArrayIi_constructorPii(i32* null, i32 0)
  store { i32, i32, i4* }* %0, { i32, i32, i4* }** %empty, align 4
  %1 = getelementptr inbounds [4 x i32], [4 x i32]* %items, i32 0, i32 0
  store i32 1, i32* %1, align 4
  %2 = getelementptr inbounds [4 x i32], [4 x i32]* %items, i32 0, i32 1
  store i32 2, i32* %2, align 4
  %3 = getelementptr inbounds [4 x i32], [4 x i32]* %items, i32 0, i32 2
  store i32 3, i32* %3, align 4
  %4 = getelementptr inbounds [4 x i32], [4 x i32]* %items, i32 0, i32 3
  store i32 4, i32* %4, align 4
  %items1 = getelementptr inbounds [4 x i32], [4 x i32]* %items, i32 0, i32 0
  %5 = call { i32, i32, i4* }* @ArrayIi_constructorPii(i32* %items1, i32 4)
  store { i32, i32, i4* }* %5, { i32, i32, i4* }** %return, align 4
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %empty2 = load { i32, i32, i4* }*, { i32, i32, i4* }** %empty, align 4
  call void @ArrayIi_free({ i32, i32, i4* }* %empty2)
  %return3 = load { i32, i32, i4* }*, { i32, i32, i4* }** %return, align 4
  ret { i32, i32, i4* }* %return3
}

declare { i32, i32, i4* }* @ArrayIi_constructorPii(i32*, i32)

declare void @ArrayIi_free({ i32, i32, i4* }*)
"
`;

exports[`Array [i] 1`] = `
"; ModuleID = '__tests__/cases/array/[i].ts'
source_filename = \\"__tests__/cases/array/[i].ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayElementAccesss() {
entry:
  %items = alloca [5 x i32]
  %array = alloca { i32, i32, i4* }*
  %0 = getelementptr inbounds [5 x i32], [5 x i32]* %items, i32 0, i32 0
  store i32 1, i32* %0, align 4
  %1 = getelementptr inbounds [5 x i32], [5 x i32]* %items, i32 0, i32 1
  store i32 2, i32* %1, align 4
  %2 = getelementptr inbounds [5 x i32], [5 x i32]* %items, i32 0, i32 2
  store i32 3, i32* %2, align 4
  %3 = getelementptr inbounds [5 x i32], [5 x i32]* %items, i32 0, i32 3
  store i32 4, i32* %3, align 4
  %4 = getelementptr inbounds [5 x i32], [5 x i32]* %items, i32 0, i32 4
  store i32 5, i32* %4, align 4
  %items1 = getelementptr inbounds [5 x i32], [5 x i32]* %items, i32 0, i32 0
  %5 = call { i32, i32, i4* }* @ArrayIi_constructorPii(i32* %items1, i32 5)
  store { i32, i32, i4* }* %5, { i32, i32, i4* }** %array, align 4
  %array2 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %array3 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %6 = call i32 @ArrayIi_geti({ i32, i32, i4* }* %array3, i32 2)
  %7 = mul i32 %6, 10
  call void @ArrayIi_setii({ i32, i32, i4* }* %array2, i32 2, i32 %7)
  %array4 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  call void @ArrayIi_free({ i32, i32, i4* }* %array4)
  ret void
}

declare { i32, i32, i4* }* @ArrayIi_constructorPii(i32*, i32)

declare i32 @ArrayIi_geti({ i32, i32, i4* }*, i32)

declare void @ArrayIi_setii({ i32, i32, i4* }*, i32, i32)

declare void @ArrayIi_free({ i32, i32, i4* }*)
"
`;

exports[`Array assignment 1`] = `
"; ModuleID = '__tests__/cases/array/assignment.ts'
source_filename = \\"__tests__/cases/array/assignment.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayAssignment() {
entry:
  %value = alloca double
  %other = alloca { i32, i32, i4* }*
  %items = alloca [3 x i32]
  %array = alloca { i32, i32, i4* }*
  %0 = getelementptr inbounds [3 x i32], [3 x i32]* %items, i32 0, i32 0
  store i32 1, i32* %0, align 4
  %1 = getelementptr inbounds [3 x i32], [3 x i32]* %items, i32 0, i32 1
  store i32 2, i32* %1, align 4
  %2 = getelementptr inbounds [3 x i32], [3 x i32]* %items, i32 0, i32 2
  store i32 3, i32* %2, align 4
  %items1 = getelementptr inbounds [3 x i32], [3 x i32]* %items, i32 0, i32 0
  %3 = call { i32, i32, i4* }* @ArrayIi_constructorPii(i32* %items1, i32 3)
  store { i32, i32, i4* }* %3, { i32, i32, i4* }** %array, align 4
  store { i32, i32, i4* }* null, { i32, i32, i4* }** %other, align 4
  %array2 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  store { i32, i32, i4* }* %array2, { i32, i32, i4* }** %other, align 4
  %other3 = load { i32, i32, i4* }*, { i32, i32, i4* }** %other, align 4
  %4 = call double @ArrayId_geti({ i32, i32, i4* }* %other3, i32 2)
  store double %4, double* %value, align 8
  %array4 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  call void @ArrayIi_free({ i32, i32, i4* }* %array4)
  %other5 = load { i32, i32, i4* }*, { i32, i32, i4* }** %other, align 4
  call void @ArrayId_free({ i32, i32, i4* }* %other5)
  ret void
}

declare { i32, i32, i4* }* @ArrayIi_constructorPii(i32*, i32)

declare double @ArrayId_geti({ i32, i32, i4* }*, i32)

declare void @ArrayId_setid({ i32, i32, i4* }*, i32, double)

declare void @ArrayIi_free({ i32, i32, i4* }*)

declare void @ArrayId_free({ i32, i32, i4* }*)
"
`;

exports[`Array fill 1`] = `
"; ModuleID = '__tests__/cases/array/fill.ts'
source_filename = \\"__tests__/cases/array/fill.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayFill() {
entry:
  %array = alloca { i32, i32, i4* }*
  %0 = call { i32, i32, i4* }* @ArrayId_constructori(i32 100)
  store { i32, i32, i4* }* %0, { i32, i32, i4* }** %array, align 4
  %array1 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %1 = call { i32, i32, i4* }* @ArrayId_filld({ i32, i32, i4* }* %array1, double 1.000000e+01)
  %array2 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %2 = call { i32, i32, i4* }* @ArrayId_filldi({ i32, i32, i4* }* %array2, double 1.000000e+01, i32 5)
  %array3 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %3 = call { i32, i32, i4* }* @ArrayId_filldii({ i32, i32, i4* }* %array3, double 1.000000e+01, i32 5, i32 50)
  %array4 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  call void @ArrayId_free({ i32, i32, i4* }* %array4)
  ret void
}

declare { i32, i32, i4* }* @ArrayId_constructori(i32)

declare { i32, i32, i4* }* @ArrayId_filld({ i32, i32, i4* }*, double)

declare { i32, i32, i4* }* @ArrayId_filldi({ i32, i32, i4* }*, double, i32)

declare { i32, i32, i4* }* @ArrayId_filldii({ i32, i32, i4* }*, double, i32, i32)

declare void @ArrayId_free({ i32, i32, i4* }*)
"
`;

exports[`Array length 1`] = `
"; ModuleID = '__tests__/cases/array/length.ts'
source_filename = \\"__tests__/cases/array/length.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayLength() {
entry:
  %i = alloca i32
  %array = alloca { i32, i32, i4* }*
  %0 = call { i32, i32, i4* }* @ArrayId_constructorPdi(double* null, i32 0)
  store { i32, i32, i4* }* %0, { i32, i32, i4* }** %array, align 4
  %array1 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  call void @ArrayId_lengthi({ i32, i32, i4* }* %array1, i32 100)
  %array2 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %1 = call i32 @ArrayId_length({ i32, i32, i4* }* %array2)
  store i32 %1, i32* %i, align 4
  %array3 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  call void @ArrayId_free({ i32, i32, i4* }* %array3)
  ret void
}

declare { i32, i32, i4* }* @ArrayId_constructorPdi(double*, i32)

declare i32 @ArrayId_length({ i32, i32, i4* }*)

declare void @ArrayId_lengthi({ i32, i32, i4* }*, i32)

declare void @ArrayId_free({ i32, i32, i4* }*)
"
`;

exports[`Array new 1`] = `
"; ModuleID = '__tests__/cases/array/new.ts'
source_filename = \\"__tests__/cases/array/new.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayConstructorCase() {
entry:
  %items2 = alloca [3 x double]
  %arrayWithElements = alloca { i32, i32, i4* }*
  %items = alloca [1 x i1]
  %arrayWithElement = alloca { i32, i32, i4* }*
  %arrayOfSize = alloca { i32, i32, i4* }*
  %emptyArray = alloca { i32, i32, i4* }*
  %0 = call { i32, i32, i4* }* @ArrayIb_constructorPbi(i1* null, i32 0)
  store { i32, i32, i4* }* %0, { i32, i32, i4* }** %emptyArray, align 4
  %1 = call { i32, i32, i4* }* @ArrayIi_constructori(i32 1000)
  store { i32, i32, i4* }* %1, { i32, i32, i4* }** %arrayOfSize, align 4
  %2 = getelementptr inbounds [1 x i1], [1 x i1]* %items, i32 0, i32 0
  store i1 true, i1* %2, align 1
  %items1 = getelementptr inbounds [1 x i1], [1 x i1]* %items, i32 0, i32 0
  %3 = call { i32, i32, i4* }* @ArrayIb_constructorPbi(i1* %items1, i32 1)
  store { i32, i32, i4* }* %3, { i32, i32, i4* }** %arrayWithElement, align 4
  %4 = getelementptr inbounds [3 x double], [3 x double]* %items2, i32 0, i32 0
  store double 1.000000e+00, double* %4, align 8
  %5 = getelementptr inbounds [3 x double], [3 x double]* %items2, i32 0, i32 1
  store double 2.000000e+00, double* %5, align 8
  %6 = getelementptr inbounds [3 x double], [3 x double]* %items2, i32 0, i32 2
  store double 3.000000e+00, double* %6, align 8
  %items3 = getelementptr inbounds [3 x double], [3 x double]* %items2, i32 0, i32 0
  %7 = call { i32, i32, i4* }* @ArrayId_constructorPdi(double* %items3, i32 3)
  store { i32, i32, i4* }* %7, { i32, i32, i4* }** %arrayWithElements, align 4
  %emptyArray4 = load { i32, i32, i4* }*, { i32, i32, i4* }** %emptyArray, align 4
  call void @ArrayIb_free({ i32, i32, i4* }* %emptyArray4)
  %arrayOfSize5 = load { i32, i32, i4* }*, { i32, i32, i4* }** %arrayOfSize, align 4
  call void @ArrayIi_free({ i32, i32, i4* }* %arrayOfSize5)
  %arrayWithElement6 = load { i32, i32, i4* }*, { i32, i32, i4* }** %arrayWithElement, align 4
  call void @ArrayIb_free({ i32, i32, i4* }* %arrayWithElement6)
  %arrayWithElements7 = load { i32, i32, i4* }*, { i32, i32, i4* }** %arrayWithElements, align 4
  call void @ArrayId_free({ i32, i32, i4* }* %arrayWithElements7)
  ret void
}

declare { i32, i32, i4* }* @ArrayIb_constructorPbi(i1*, i32)

declare { i32, i32, i4* }* @ArrayIi_constructori(i32)

declare { i32, i32, i4* }* @ArrayId_constructorPdi(double*, i32)

declare void @ArrayIb_free({ i32, i32, i4* }*)

declare void @ArrayIi_free({ i32, i32, i4* }*)

declare void @ArrayId_free({ i32, i32, i4* }*)
"
`;

exports[`Array pop 1`] = `
"; ModuleID = '__tests__/cases/array/pop.ts'
source_filename = \\"__tests__/cases/array/pop.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayPop() {
entry:
  %end = alloca i32
  %items = alloca [2 x i32]
  %array = alloca { i32, i32, i4* }*
  %0 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 0
  store i32 1, i32* %0, align 4
  %1 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 1
  store i32 2, i32* %1, align 4
  %items1 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 0
  %2 = call { i32, i32, i4* }* @ArrayIi_constructorPii(i32* %items1, i32 2)
  store { i32, i32, i4* }* %2, { i32, i32, i4* }** %array, align 4
  %array2 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %3 = call i32 @ArrayIi_pop({ i32, i32, i4* }* %array2)
  store i32 %3, i32* %end, align 4
  %array3 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  call void @ArrayIi_free({ i32, i32, i4* }* %array3)
  ret void
}

declare { i32, i32, i4* }* @ArrayIi_constructorPii(i32*, i32)

declare i32 @ArrayIi_pop({ i32, i32, i4* }*)

declare void @ArrayIi_free({ i32, i32, i4* }*)
"
`;

exports[`Array push 1`] = `
"; ModuleID = '__tests__/cases/array/push.ts'
source_filename = \\"__tests__/cases/array/push.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayPush() {
entry:
  %items7 = alloca [3 x i32]
  %newLength = alloca i32
  %items4 = alloca [1 x i32]
  %items = alloca [2 x i32]
  %array = alloca { i32, i32, i4* }*
  %0 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 0
  store i32 1, i32* %0, align 4
  %1 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 1
  store i32 2, i32* %1, align 4
  %items1 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 0
  %2 = call { i32, i32, i4* }* @ArrayIi_constructorPii(i32* %items1, i32 2)
  store { i32, i32, i4* }* %2, { i32, i32, i4* }** %array, align 4
  %array2 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %3 = call i32 @ArrayIi_pushPii({ i32, i32, i4* }* %array2, i32* null, i32 0)
  %array3 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %4 = getelementptr inbounds [1 x i32], [1 x i32]* %items4, i32 0, i32 0
  store i32 1, i32* %4, align 4
  %items5 = getelementptr inbounds [1 x i32], [1 x i32]* %items4, i32 0, i32 0
  %5 = call i32 @ArrayIi_pushPii({ i32, i32, i4* }* %array3, i32* %items5, i32 1)
  %array6 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %6 = getelementptr inbounds [3 x i32], [3 x i32]* %items7, i32 0, i32 0
  store i32 1, i32* %6, align 4
  %7 = getelementptr inbounds [3 x i32], [3 x i32]* %items7, i32 0, i32 1
  store i32 2, i32* %7, align 4
  %8 = getelementptr inbounds [3 x i32], [3 x i32]* %items7, i32 0, i32 2
  store i32 3, i32* %8, align 4
  %items8 = getelementptr inbounds [3 x i32], [3 x i32]* %items7, i32 0, i32 0
  %9 = call i32 @ArrayIi_pushPii({ i32, i32, i4* }* %array6, i32* %items8, i32 3)
  store i32 %9, i32* %newLength, align 4
  %array9 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  call void @ArrayIi_free({ i32, i32, i4* }* %array9)
  ret void
}

declare { i32, i32, i4* }* @ArrayIi_constructorPii(i32*, i32)

declare i32 @ArrayIi_pushPii({ i32, i32, i4* }*, i32*, i32)

declare void @ArrayIi_free({ i32, i32, i4* }*)
"
`;

exports[`Array shift 1`] = `
"; ModuleID = '__tests__/cases/array/shift.ts'
source_filename = \\"__tests__/cases/array/shift.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayShift() {
entry:
  %front = alloca i32
  %items = alloca [2 x i32]
  %array = alloca { i32, i32, i4* }*
  %0 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 0
  store i32 1, i32* %0, align 4
  %1 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 1
  store i32 2, i32* %1, align 4
  %items1 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 0
  %2 = call { i32, i32, i4* }* @ArrayIi_constructorPii(i32* %items1, i32 2)
  store { i32, i32, i4* }* %2, { i32, i32, i4* }** %array, align 4
  %array2 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %3 = call i32 @ArrayIi_shift({ i32, i32, i4* }* %array2)
  store i32 %3, i32* %front, align 4
  %array3 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  call void @ArrayIi_free({ i32, i32, i4* }* %array3)
  ret void
}

declare { i32, i32, i4* }* @ArrayIi_constructorPii(i32*, i32)

declare i32 @ArrayIi_shift({ i32, i32, i4* }*)

declare void @ArrayIi_free({ i32, i32, i4* }*)
"
`;

exports[`Array unshift 1`] = `
"; ModuleID = '__tests__/cases/array/unshift.ts'
source_filename = \\"__tests__/cases/array/unshift.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayUnshift() {
entry:
  %items7 = alloca [3 x i32]
  %newLength = alloca i32
  %items4 = alloca [1 x i32]
  %items = alloca [2 x i32]
  %array = alloca { i32, i32, i4* }*
  %0 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 0
  store i32 1, i32* %0, align 4
  %1 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 1
  store i32 2, i32* %1, align 4
  %items1 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 0
  %2 = call { i32, i32, i4* }* @ArrayIi_constructorPii(i32* %items1, i32 2)
  store { i32, i32, i4* }* %2, { i32, i32, i4* }** %array, align 4
  %array2 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %3 = call i32 @ArrayIi_unshiftPii({ i32, i32, i4* }* %array2, i32* null, i32 0)
  %array3 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %4 = getelementptr inbounds [1 x i32], [1 x i32]* %items4, i32 0, i32 0
  store i32 1, i32* %4, align 4
  %items5 = getelementptr inbounds [1 x i32], [1 x i32]* %items4, i32 0, i32 0
  %5 = call i32 @ArrayIi_unshiftPii({ i32, i32, i4* }* %array3, i32* %items5, i32 1)
  %array6 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  %6 = getelementptr inbounds [3 x i32], [3 x i32]* %items7, i32 0, i32 0
  store i32 1, i32* %6, align 4
  %7 = getelementptr inbounds [3 x i32], [3 x i32]* %items7, i32 0, i32 1
  store i32 2, i32* %7, align 4
  %8 = getelementptr inbounds [3 x i32], [3 x i32]* %items7, i32 0, i32 2
  store i32 3, i32* %8, align 4
  %items8 = getelementptr inbounds [3 x i32], [3 x i32]* %items7, i32 0, i32 0
  %9 = call i32 @ArrayIi_unshiftPii({ i32, i32, i4* }* %array6, i32* %items8, i32 3)
  store i32 %9, i32* %newLength, align 4
  %array9 = load { i32, i32, i4* }*, { i32, i32, i4* }** %array, align 4
  call void @ArrayIi_free({ i32, i32, i4* }* %array9)
  ret void
}

declare { i32, i32, i4* }* @ArrayIi_constructorPii(i32*, i32)

declare i32 @ArrayIi_unshiftPii({ i32, i32, i4* }*, i32*, i32)

declare void @ArrayIi_free({ i32, i32, i4* }*)
"
`;
