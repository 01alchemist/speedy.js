// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Array [1, 2, 3] 1`] = `
"; ModuleID = '__tests__/cases/array/[1, 2, 3].ts'
source_filename = \\"__tests__/cases/array/[1, 2, 3].ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define i4* @arrayLiteral() {
entry:
  %elements = alloca [4 x i32]
  %return = alloca i4*
  %0 = getelementptr inbounds [4 x i32], [4 x i32]* %elements, i32 0, i32 0
  store i32 1, i32* %0, align 4
  %1 = getelementptr inbounds [4 x i32], [4 x i32]* %elements, i32 0, i32 1
  store i32 2, i32* %1, align 4
  %2 = getelementptr inbounds [4 x i32], [4 x i32]* %elements, i32 0, i32 2
  store i32 3, i32* %2, align 4
  %3 = getelementptr inbounds [4 x i32], [4 x i32]* %elements, i32 0, i32 3
  store i32 4, i32* %3, align 4
  %elements1 = getelementptr inbounds [4 x i32], [4 x i32]* %elements, i32 0, i32 0
  %4 = call i4* @new_array_i32(i32 4, i32* %elements1)
  store i4* %4, i4** %return, align 4
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return2 = load i4*, i4** %return, align 4
  ret i4* %return2
}

declare i4* @new_array_i32(i32, i32*)
"
`;

exports[`Array [i] 1`] = `
"; ModuleID = '__tests__/cases/array/[i].ts'
source_filename = \\"__tests__/cases/array/[i].ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayElementAccesss() {
entry:
  %elements = alloca [5 x i32]
  %array = alloca i4*
  %0 = getelementptr inbounds [5 x i32], [5 x i32]* %elements, i32 0, i32 0
  store i32 1, i32* %0, align 4
  %1 = getelementptr inbounds [5 x i32], [5 x i32]* %elements, i32 0, i32 1
  store i32 2, i32* %1, align 4
  %2 = getelementptr inbounds [5 x i32], [5 x i32]* %elements, i32 0, i32 2
  store i32 3, i32* %2, align 4
  %3 = getelementptr inbounds [5 x i32], [5 x i32]* %elements, i32 0, i32 3
  store i32 4, i32* %3, align 4
  %4 = getelementptr inbounds [5 x i32], [5 x i32]* %elements, i32 0, i32 4
  store i32 5, i32* %4, align 4
  %elements1 = getelementptr inbounds [5 x i32], [5 x i32]* %elements, i32 0, i32 0
  %5 = call i4* @new_array_i32(i32 5, i32* %elements1)
  store i4* %5, i4** %array, align 4
  %array2 = load i4*, i4** %array, align 4
  %array3 = load i4*, i4** %array, align 4
  %6 = call i32 @array_get_i32(i4* %array3, i32 2)
  %7 = mul i32 %6, 10
  call void @array_set_i32(i4* %array2, i32 2, i32 %7)
  %array4 = load i4*, i4** %array, align 4
  call void @delete_array_i32(i4* %array4)
  ret void
}

declare i4* @new_array_i32(i32, i32*)

declare i32 @array_get_i32(i4*, i32)

declare void @array_set_i32(i4*, i32, i32)

declare void @delete_array_i32(i4*)
"
`;

exports[`Array assignment 1`] = `
"; ModuleID = '__tests__/cases/array/assignment.ts'
source_filename = \\"__tests__/cases/array/assignment.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayAssignment() {
entry:
  %value = alloca double
  %other = alloca i4*
  %elements = alloca [3 x i32]
  %array = alloca i4*
  %0 = getelementptr inbounds [3 x i32], [3 x i32]* %elements, i32 0, i32 0
  store i32 1, i32* %0, align 4
  %1 = getelementptr inbounds [3 x i32], [3 x i32]* %elements, i32 0, i32 1
  store i32 2, i32* %1, align 4
  %2 = getelementptr inbounds [3 x i32], [3 x i32]* %elements, i32 0, i32 2
  store i32 3, i32* %2, align 4
  %elements1 = getelementptr inbounds [3 x i32], [3 x i32]* %elements, i32 0, i32 0
  %3 = call i4* @new_array_i32(i32 3, i32* %elements1)
  store i4* %3, i4** %array, align 4
  store i4* null, i4** %other, align 4
  %array2 = load i4*, i4** %array, align 4
  store i4* %array2, i4** %other, align 4
  %other3 = load i4*, i4** %other, align 4
  %4 = call double @array_get_f64(i4* %other3, i32 2)
  store double %4, double* %value, align 8
  %array4 = load i4*, i4** %array, align 4
  call void @delete_array_i32(i4* %array4)
  %other5 = load i4*, i4** %other, align 4
  call void @delete_array_f64(i4* %other5)
  ret void
}

declare i4* @new_array_i32(i32, i32*)

declare double @array_get_f64(i4*, i32)

declare void @array_set_f64(i4*, i32, double)

declare void @delete_array_i32(i4*)

declare void @delete_array_f64(i4*)
"
`;

exports[`Array fill 1`] = `
"; ModuleID = '__tests__/cases/array/fill.ts'
source_filename = \\"__tests__/cases/array/fill.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayFill() {
entry:
  %array = alloca i4*
  %0 = call i4* @new_array_f64(i32 100, double* null)
  store i4* %0, i4** %array, align 4
  %array1 = load i4*, i4** %array, align 4
  %1 = call i4* @array_fill_ii_f64(i4* %array1, double 1.000000e+01, i32 0)
  %array2 = load i4*, i4** %array, align 4
  %2 = call i4* @array_fill_ii_f64(i4* %array2, double 1.000000e+01, i32 5)
  %array3 = load i4*, i4** %array, align 4
  %3 = call i4* @array_fill_iii_f64(i4* %array3, double 1.000000e+01, i32 5, i32 50)
  %array4 = load i4*, i4** %array, align 4
  call void @delete_array_f64(i4* %array4)
  ret void
}

declare i4* @new_array_f64(i32, double*)

declare i4* @array_fill_ii_f64(i4*, double, i32)

declare i4* @array_fill_iii_f64(i4*, double, i32, i32)

declare void @delete_array_f64(i4*)
"
`;

exports[`Array length 1`] = `
"; ModuleID = '__tests__/cases/array/length.ts'
source_filename = \\"__tests__/cases/array/length.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayLength() {
entry:
  %i = alloca i32
  %array = alloca i4*
  %0 = call i4* @new_array_f64(i32 0, double* null)
  store i4* %0, i4** %array, align 4
  %array1 = load i4*, i4** %array, align 4
  %1 = call i32 @array_set_length_f64(i4* %array1, i32 100)
  %array2 = load i4*, i4** %array, align 4
  %2 = call i32 @array_length_f64(i4* %array2)
  store i32 %2, i32* %i, align 4
  %array3 = load i4*, i4** %array, align 4
  call void @delete_array_f64(i4* %array3)
  ret void
}

declare i4* @new_array_f64(i32, double*)

declare i32 @array_length_f64(i4*)

declare i32 @array_set_length_f64(i4*, i32)

declare void @delete_array_f64(i4*)
"
`;

exports[`Array new 1`] = `
"; ModuleID = '__tests__/cases/array/new.ts'
source_filename = \\"__tests__/cases/array/new.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayConstructorCase() {
entry:
  %elements2 = alloca [3 x double]
  %arrayWithElements = alloca i4*
  %elements = alloca [1 x i1]
  %arrayWithElement = alloca i4*
  %arrayOfSize = alloca i4*
  %emptyArray = alloca i4*
  %0 = call i4* @new_array_i1(i32 0, i1* null)
  store i4* %0, i4** %emptyArray, align 4
  %1 = call i4* @new_array_i32(i32 1000, i32* null)
  store i4* %1, i4** %arrayOfSize, align 4
  %2 = getelementptr inbounds [1 x i1], [1 x i1]* %elements, i32 0, i32 0
  store i1 true, i1* %2, align 1
  %elements1 = getelementptr inbounds [1 x i1], [1 x i1]* %elements, i32 0, i32 0
  %3 = call i4* @new_array_i1(i32 1, i1* %elements1)
  store i4* %3, i4** %arrayWithElement, align 4
  %4 = getelementptr inbounds [3 x double], [3 x double]* %elements2, i32 0, i32 0
  store double 1.000000e+00, double* %4, align 8
  %5 = getelementptr inbounds [3 x double], [3 x double]* %elements2, i32 0, i32 1
  store double 2.000000e+00, double* %5, align 8
  %6 = getelementptr inbounds [3 x double], [3 x double]* %elements2, i32 0, i32 2
  store double 3.000000e+00, double* %6, align 8
  %elements3 = getelementptr inbounds [3 x double], [3 x double]* %elements2, i32 0, i32 0
  %7 = call i4* @new_array_f64(i32 3, double* %elements3)
  store i4* %7, i4** %arrayWithElements, align 4
  %emptyArray4 = load i4*, i4** %emptyArray, align 4
  call void @delete_array_i1(i4* %emptyArray4)
  %arrayOfSize5 = load i4*, i4** %arrayOfSize, align 4
  call void @delete_array_i32(i4* %arrayOfSize5)
  %arrayWithElement6 = load i4*, i4** %arrayWithElement, align 4
  call void @delete_array_i1(i4* %arrayWithElement6)
  %arrayWithElements7 = load i4*, i4** %arrayWithElements, align 4
  call void @delete_array_f64(i4* %arrayWithElements7)
  ret void
}

declare i4* @new_array_i1(i32, i1*)

declare i4* @new_array_i32(i32, i32*)

declare i4* @new_array_f64(i32, double*)

declare void @delete_array_i1(i4*)

declare void @delete_array_i32(i4*)

declare void @delete_array_f64(i4*)
"
`;

exports[`Array pop 1`] = `
"; ModuleID = '__tests__/cases/array/pop.ts'
source_filename = \\"__tests__/cases/array/pop.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayPop() {
entry:
  %end = alloca i32
  %elements = alloca [2 x i32]
  %array = alloca i4*
  %0 = getelementptr inbounds [2 x i32], [2 x i32]* %elements, i32 0, i32 0
  store i32 1, i32* %0, align 4
  %1 = getelementptr inbounds [2 x i32], [2 x i32]* %elements, i32 0, i32 1
  store i32 2, i32* %1, align 4
  %elements1 = getelementptr inbounds [2 x i32], [2 x i32]* %elements, i32 0, i32 0
  %2 = call i4* @new_array_i32(i32 2, i32* %elements1)
  store i4* %2, i4** %array, align 4
  %array2 = load i4*, i4** %array, align 4
  %3 = call i32 @pop_i32(i4* %array2)
  store i32 %3, i32* %end, align 4
  %array3 = load i4*, i4** %array, align 4
  call void @delete_array_i32(i4* %array3)
  ret void
}

declare i4* @new_array_i32(i32, i32*)

declare i32 @pop_i32(i4*)

declare void @delete_array_i32(i4*)
"
`;

exports[`Array push 1`] = `
"; ModuleID = '__tests__/cases/array/push.ts'
source_filename = \\"__tests__/cases/array/push.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayPush() {
entry:
  %0 = alloca [3 x i32]
  %newLength = alloca i32
  %1 = alloca [1 x i32]
  %elements = alloca [2 x i32]
  %array = alloca i4*
  %2 = getelementptr inbounds [2 x i32], [2 x i32]* %elements, i32 0, i32 0
  store i32 1, i32* %2, align 4
  %3 = getelementptr inbounds [2 x i32], [2 x i32]* %elements, i32 0, i32 1
  store i32 2, i32* %3, align 4
  %elements1 = getelementptr inbounds [2 x i32], [2 x i32]* %elements, i32 0, i32 0
  %4 = call i4* @new_array_i32(i32 2, i32* %elements1)
  store i4* %4, i4** %array, align 4
  %array2 = load i4*, i4** %array, align 4
  %5 = call i32 @push_i32(i4* %array2, i32* null, i32 0)
  %array3 = load i4*, i4** %array, align 4
  %6 = getelementptr inbounds [1 x i32], [1 x i32]* %1, i32 0, i32 0
  store i32 1, i32* %6, align 4
  %7 = getelementptr inbounds [1 x i32], [1 x i32]* %1, i32 0, i32 0
  %8 = call i32 @push_i32(i4* %array3, i32* %7, i32 1)
  %array4 = load i4*, i4** %array, align 4
  %9 = getelementptr inbounds [3 x i32], [3 x i32]* %0, i32 0, i32 0
  store i32 1, i32* %9, align 4
  %10 = getelementptr inbounds [3 x i32], [3 x i32]* %0, i32 0, i32 1
  store i32 2, i32* %10, align 4
  %11 = getelementptr inbounds [3 x i32], [3 x i32]* %0, i32 0, i32 2
  store i32 3, i32* %11, align 4
  %12 = getelementptr inbounds [3 x i32], [3 x i32]* %0, i32 0, i32 0
  %13 = call i32 @push_i32(i4* %array4, i32* %12, i32 3)
  store i32 %13, i32* %newLength, align 4
  %array5 = load i4*, i4** %array, align 4
  call void @delete_array_i32(i4* %array5)
  ret void
}

declare i4* @new_array_i32(i32, i32*)

declare i32 @push_i32(i4*, i32*, i32)

declare void @delete_array_i32(i4*)
"
`;

exports[`Array shift 1`] = `
"; ModuleID = '__tests__/cases/array/shift.ts'
source_filename = \\"__tests__/cases/array/shift.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayShift() {
entry:
  %front = alloca i32
  %elements = alloca [2 x i32]
  %array = alloca i4*
  %0 = getelementptr inbounds [2 x i32], [2 x i32]* %elements, i32 0, i32 0
  store i32 1, i32* %0, align 4
  %1 = getelementptr inbounds [2 x i32], [2 x i32]* %elements, i32 0, i32 1
  store i32 2, i32* %1, align 4
  %elements1 = getelementptr inbounds [2 x i32], [2 x i32]* %elements, i32 0, i32 0
  %2 = call i4* @new_array_i32(i32 2, i32* %elements1)
  store i4* %2, i4** %array, align 4
  %array2 = load i4*, i4** %array, align 4
  %3 = call i32 @shift_i32(i4* %array2)
  store i32 %3, i32* %front, align 4
  %array3 = load i4*, i4** %array, align 4
  call void @delete_array_i32(i4* %array3)
  ret void
}

declare i4* @new_array_i32(i32, i32*)

declare i32 @shift_i32(i4*)

declare void @delete_array_i32(i4*)
"
`;

exports[`Array unshift 1`] = `
"; ModuleID = '__tests__/cases/array/unshift.ts'
source_filename = \\"__tests__/cases/array/unshift.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @arrayUnshift() {
entry:
  %0 = alloca [3 x i32]
  %newLength = alloca i32
  %1 = alloca [1 x i32]
  %elements = alloca [2 x i32]
  %array = alloca i4*
  %2 = getelementptr inbounds [2 x i32], [2 x i32]* %elements, i32 0, i32 0
  store i32 1, i32* %2, align 4
  %3 = getelementptr inbounds [2 x i32], [2 x i32]* %elements, i32 0, i32 1
  store i32 2, i32* %3, align 4
  %elements1 = getelementptr inbounds [2 x i32], [2 x i32]* %elements, i32 0, i32 0
  %4 = call i4* @new_array_i32(i32 2, i32* %elements1)
  store i4* %4, i4** %array, align 4
  %array2 = load i4*, i4** %array, align 4
  %5 = call i32 @unshift_i32(i4* %array2, i32* null, i32 0)
  %array3 = load i4*, i4** %array, align 4
  %6 = getelementptr inbounds [1 x i32], [1 x i32]* %1, i32 0, i32 0
  store i32 1, i32* %6, align 4
  %7 = getelementptr inbounds [1 x i32], [1 x i32]* %1, i32 0, i32 0
  %8 = call i32 @unshift_i32(i4* %array3, i32* %7, i32 1)
  %array4 = load i4*, i4** %array, align 4
  %9 = getelementptr inbounds [3 x i32], [3 x i32]* %0, i32 0, i32 0
  store i32 1, i32* %9, align 4
  %10 = getelementptr inbounds [3 x i32], [3 x i32]* %0, i32 0, i32 1
  store i32 2, i32* %10, align 4
  %11 = getelementptr inbounds [3 x i32], [3 x i32]* %0, i32 0, i32 2
  store i32 3, i32* %11, align 4
  %12 = getelementptr inbounds [3 x i32], [3 x i32]* %0, i32 0, i32 0
  %13 = call i32 @unshift_i32(i4* %array4, i32* %12, i32 3)
  store i32 %13, i32* %newLength, align 4
  %array5 = load i4*, i4** %array, align 4
  call void @delete_array_i32(i4* %array5)
  ret void
}

declare i4* @new_array_i32(i32, i32*)

declare i32 @unshift_i32(i4*, i32*, i32)

declare void @delete_array_i32(i4*)
"
`;
