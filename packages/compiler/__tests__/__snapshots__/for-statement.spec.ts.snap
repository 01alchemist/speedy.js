// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ForStatement for-empty 1`] = `
"; ModuleID = '__tests__/cases/for/for-empty.ts'
source_filename = \\"__tests__/cases/for/for-empty.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @forEmpty() {
entry:
  br label %for-body

for-body:                                         ; preds = %entry
  br label %for-successor

for-successor:                                    ; preds = %for-body
  ret void
}
"
`;

exports[`ForStatement with-condition 1`] = `
"; ModuleID = '__tests__/cases/for/with-condition.ts'
source_filename = \\"__tests__/cases/for/with-condition.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @forWithCondition() {
entry:
  %i = alloca i32
  store i32 0, i32* %i, align 4
  br label %for-header

for-header:                                       ; preds = %for-body, %entry
  %i1 = load i32, i32* %i, align 4
  %0 = icmp slt i32 %i1, 10
  br i1 %0, label %for-body, label %for-successor

for-body:                                         ; preds = %for-header
  br label %for-header

for-successor:                                    ; preds = %for-header
  ret void
}
"
`;

exports[`ForStatement with-initializer 1`] = `
"; ModuleID = '__tests__/cases/for/with-initializer.ts'
source_filename = \\"__tests__/cases/for/with-initializer.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @forWithInitializer() {
entry:
  %i = alloca i32
  store i32 0, i32* %i, align 4
  br label %for-body

for-body:                                         ; preds = %entry
  br label %for-successor

for-successor:                                    ; preds = %for-body
  ret void
}
"
`;

exports[`ForStatement with-return-statement 1`] = `
"; ModuleID = '__tests__/cases/for/with-return-statement.ts'
source_filename = \\"__tests__/cases/for/with-return-statement.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define i1 @isPrime(i32 %x1) {
entry:
  %i = alloca i32
  %x = alloca i32
  store i32 %x1, i32* %x, align 4
  %return = alloca i1
  %x2 = load i32, i32* %x, align 4
  %0 = icmp sle i32 %x2, 2
  br i1 %0, label %then, label %if-successor

then:                                             ; preds = %entry
  store i1 false, i1* %return, align 1
  br label %returnBlock

if-successor:                                     ; preds = %entry
  store i32 2, i32* %i, align 4
  br label %for-header

for-header:                                       ; preds = %if-successor8, %if-successor
  %mathPtr = load { { [5 x i8]* }* }*, { { [5 x i8]* }* }** @Math_ptr, align 4
  %x3 = load i32, i32* %x, align 4
  %1 = sitofp i32 %x3 to double
  %2 = call double @llvm.sqrt.f64(double %1)
  %3 = fptosi double %2 to i32
  %i4 = load i32, i32* %i, align 4
  %4 = icmp slt i32 %i4, %3
  br i1 %4, label %for-body, label %for-successor

for-body:                                         ; preds = %for-header
  %i5 = load i32, i32* %i, align 4
  %x6 = load i32, i32* %x, align 4
  %5 = srem i32 %x6, %i5
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %then7, label %if-successor8

then7:                                            ; preds = %for-body
  store i1 false, i1* %return, align 1
  br label %returnBlock

if-successor8:                                    ; preds = %for-body
  %i9 = load i32, i32* %i, align 4
  %7 = add i32 %i9, 1
  store i32 %7, i32* %i, align 4
  br label %for-header

for-successor:                                    ; preds = %for-header
  store i1 true, i1* %return, align 1
  br label %returnBlock

returnBlock:                                      ; preds = %for-successor, %then7, %then
  %return10 = load i1, i1* %return, align 1
  ret i1 %return10
}

; Function Attrs: nounwind readnone
declare double @llvm.sqrt.f64(double) #0

attributes #0 = { nounwind readnone }
"
`;

exports[`ForStatement with-updater 1`] = `
"; ModuleID = '__tests__/cases/for/with-updater.ts'
source_filename = \\"__tests__/cases/for/with-updater.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @forWithUpdater() {
entry:
  %i = alloca i32
  %x = alloca i32
  store i32 0, i32* %x, align 4
  store i32 0, i32* %i, align 4
  br label %for-header

for-header:                                       ; preds = %for-body, %entry
  %i1 = load i32, i32* %i, align 4
  %0 = icmp slt i32 %i1, 10
  br i1 %0, label %for-body, label %for-successor

for-body:                                         ; preds = %for-header
  %i2 = load i32, i32* %i, align 4
  store i32 %i2, i32* %x, align 4
  %i3 = load i32, i32* %i, align 4
  %1 = add i32 %i3, 1
  store i32 %1, i32* %i, align 4
  br label %for-header

for-successor:                                    ; preds = %for-header
  ret void
}
"
`;
